import re
from typing import Any, Dict, List, Literal, Optional, Tuple

from pydantic import BaseModel, Field

from logger import get_logger
from models import rule_generation_prompt_template_en

logger = get_logger(name=__name__)

# Define the exact types of rules that your system understands
RuleType = Literal["regex", "keyword", "position"]

# Define the exact strategies for rules of type "keyword"
KeywordStrategy = Literal["next_line", "multiline_until_stop", "conditional_null"]


class Rule(BaseModel):
    """Stores a single extraction rule generated by the Learning Loop."""

    type: RuleType = Field(
        ..., description="The main type of the rule (regex, keyword, or position)"
    )

    rule: Optional[str] = Field(
        None,
        description=r"The regex pattern to be executed. (Ex: 'Inscrição[^\d]*(\d{6})')",
    )

    keyword: Optional[str] = Field(
        None, description="The 'anchor' keyword to search for in the text."
    )

    strategy: Optional[KeywordStrategy] = Field(
        None, description="The action to take after finding the keyword."
    )

    stop_keyword: Optional[str] = Field(
        None,
        description="Where to stop for 'multiline' or what to check for 'conditional'.",
    )

    line_number: Optional[int] = Field(
        None,
        description="The line number to extract (e.g., 1 for the first line).",
    )

    validation_regex: str = Field(
        ...,
        description=r"A simple regex to validate the *format* of the extracted value (e.g., '^\d{6}$').",
    )

    def apply(self, text: Optional[str]) -> Optional[str]:
        """Applies this rule to the given text and returns the extracted value."""
        if not text:
            return None
        try:
            return execute_rule(self, text)
        except Exception as e:
            logger.error(f"Error applying rule: {e}")
            return None

    def validate(self, text: Optional[str]) -> bool:
        """Validates the text against the validation regex.

        Special handling for __NULL__ marker from conditional_null strategy:
        - If text is "__NULL__", it should match a validation_regex for null values
        - For non-null values, the regex should NOT match "__NULL__"
        """
        if not text:
            return False
        try:
            return re.match(self.validation_regex, text) is not None
        except Exception as e:
            logger.error(f"Error validating text: {e}")
            return False


def create_rule_generation_prompt(
    text: str,
    field_name: str,
    field_value: str,
    field_description: str,
    other_keywords: List[str],
) -> str:
    return rule_generation_prompt_template_en.format(
        text=text,
        field_name=field_name,
        field_value=field_value,
        field_description=field_description,
        other_keywords=other_keywords,
    )


def _execute_position_rule(rule: Rule, text: str) -> Optional[str]:
    """Applies a 'position' type rule."""
    if not rule.line_number or rule.line_number <= 0:
        return None  # Invalid line number

    lines = text.splitlines()

    # -1 because line_number is 1-based, list is 0-based
    line_index = rule.line_number - 1

    if line_index < len(lines):
        return lines[line_index].strip()

    return None  # Line number out of range


def _execute_keyword_rule(rule: Rule, text: str) -> Optional[str]:
    """Applies a 'keyword' type rule.

    Special behavior for 'conditional_null' strategy:
    - Returns "__NULL__" when field is genuinely null (empty between keywords)
    - Returns None when rule doesn't match (has value or stop_keyword not found)
    """
    if not rule.keyword:
        return None

    # Find the keyword
    keyword_pos = text.find(rule.keyword)
    if keyword_pos == -1:
        return None  # Keyword not found

    # Get all text *after* the keyword
    start_pos = keyword_pos + len(rule.keyword)
    text_after = text[start_pos:]

    # --- Apply Strategy ---

    if rule.strategy == "next_line":
        # Finds the first non-empty line after the keyword
        for line in text_after.splitlines():
            stripped_line = line.strip()
            if stripped_line:
                return stripped_line
        return None  # No non-empty line found

    elif rule.strategy == "multiline_until_stop":
        if not rule.stop_keyword:
            return text_after.strip()  # No stop, return all text after

        # Find the stop_keyword *in the text after the keyword*
        stop_pos = text_after.find(rule.stop_keyword)

        if stop_pos != -1:
            # Return everything between keyword and stop_keyword
            return text_after[:stop_pos].strip()
        else:
            # Stop keyword wasn't found, so this rule fails
            return None

    elif rule.strategy == "conditional_null":
        """
        Robust conditional_null implementation:
        
        This strategy detects when a field is genuinely null (empty/missing).
        It checks if there's only whitespace between the keyword and stop_keyword.
        
        **Enhanced for last fields:** If stop_keyword is None or not found,
        checks from keyword to end of text (for fields at the end of document).
        
        Returns:
        - "__NULL__": Field is genuinely null (success case)
        - None: Rule doesn't match (failure case - field has value)
        
        Example success cases (should return "__NULL__"):
            1. With stop_keyword: "Categoria\n\nEndereco Profissional"
               keyword="Categoria", stop_keyword="Endereco Profissional"
               → Between keywords: "\n\n" (only whitespace) → Return "__NULL__"
            
            2. Last field (no stop_keyword): "Situacao\t"
               keyword="Situacao", stop_keyword=None
               → After keyword: "\t" (only whitespace) → Return "__NULL__"
            
            3. Last field (stop_keyword not found): "Situacao\n"
               keyword="Situacao", stop_keyword="NextField"
               → stop_keyword not found, text after: "\n" (only whitespace) → Return "__NULL__"
               
        Example failure cases (should return None):
            1. Has value: "Categoria\nADVOGADO\nEndereco Profissional"
               → Between keywords: "\nADVOGADO\n" (has content) → Return None

            2. Last field with value: "Situacao\nSituação Regular"
               → After keyword: "\nSituação Regular" (has content) → Return None
        """
        # Determine the text region to check
        if rule.stop_keyword:
            # Try to find the stop_keyword
            stop_pos = text_after.find(rule.stop_keyword)

            if stop_pos != -1:
                # Stop keyword found - check text between keyword and stop_keyword
                between_text = text_after[:stop_pos]
            else:
                # Stop keyword NOT found - this could be the last field
                # Check from keyword to end of text
                between_text = text_after
                logger.debug(
                    "conditional_null: stop_keyword '%s' not found, treating as last field",
                    rule.stop_keyword,
                )
        else:
            # No stop_keyword specified - this is the last field
            # Check from keyword to end of text
            between_text = text_after
            logger.debug(
                "conditional_null: no stop_keyword specified, treating as last field"
            )

        # Check if there's only whitespace in the region
        if not between_text.strip():
            # Success! The field is genuinely null (empty)
            if rule.stop_keyword and text_after.find(rule.stop_keyword) != -1:
                logger.debug(
                    "conditional_null: Field is NULL - only whitespace between '%s' and '%s'",
                    rule.keyword,
                    rule.stop_keyword,
                )
            else:
                logger.debug(
                    "conditional_null: Field is NULL - only whitespace after '%s' (last field)",
                    rule.keyword,
                )
            return "__NULL__"  # Special marker indicating genuine null
        else:
            # Failure - there's actual content in the region
            # This means the field has a value, so this null-detection rule doesn't match
            logger.debug(
                "conditional_null: Field has value (not null) - found content: '%s'",
                between_text.strip()[:50],  # Log first 50 chars
            )
            return None

    return None


# (Assumes your Rule, RuleType, and KeywordStrategy models are defined)
def _execute_regex_rule(rule: Rule, text: str) -> Optional[str]:
    """Applies a 'regex' type rule."""
    if not rule.rule:
        return None

    # re.DOTALL makes the '.' special character match any character,
    # including a newline. This is crucial for multi-line fields.
    match = re.search(rule.rule, text, re.DOTALL)

    if match:
        try:
            # .group(1) extracts the text from the *first capture group*
            # This is the standard for extraction regex.
            return match.group(1).strip()
        except IndexError:
            # This happens if the regex matched but had NO capture group.
            # We can fall back to group(0), the full match.
            return match.group(0).strip()

    return None  # No match found


def execute_rule(rule: Rule, text: str) -> Optional[str]:
    """Executes a given extraction rule on the input text.

    This function acts as a dispatcher, calling the correct
    sub-function based on the rule's 'type'.
    """
    try:
        if rule.type == "regex":
            return _execute_regex_rule(rule, text)
        elif rule.type == "keyword":
            return _execute_keyword_rule(rule, text)
        elif rule.type == "position":
            return _execute_position_rule(rule, text)
    except Exception as e:
        # Catch any unexpected errors during rule execution
        print(f"Error executing rule (type: {rule.type}, rule: {rule.rule}): {e}")
        return None

    return None


def _validate_syntax(
    response: Dict[str, Any],
    field_name: str,
    attempt: int,
) -> Tuple[Optional[Rule], Optional[str]]:
    stage = "syntax_validation"
    try:
        # 4. Validate Syntax (Schema)
        rule = Rule.model_validate(response.get("structured_response", {}))
        extra = {
            "field": field_name,
            "attempt": attempt,
            "stage": stage,
        }
        logger.debug(
            f"Syntax validation successful: {extra}",
        )
        return rule, None
    except Exception as e:
        feedback = (
            f"- ATTEMPT {attempt} FAILED: The JSON was malformed or failed schema validation. "
            f"Error: {e}. Make sure to return ONLY valid JSON matching the schema."
        )
        extra = {
            "field": field_name,
            "attempt": attempt,
            "stage": stage,
            "error": str(e),
            "raw_response": response,
        }
        logger.warning(
            f"Syntax validation failed: {extra}",
        )
        return None, feedback


def _validate_extraction_rule(
    rule: Rule,
    text: str,
    field_value: str,
    field_name: str,
    attempt: int,
) -> Optional[str]:
    """Validate that the rule extracts the expected value.

    Special handling for conditional_null strategy:
    - If field_value is None, expect rule to return "__NULL__"
    - If field_value is not None, rule should NOT return "__NULL__"
    """
    stage = "extraction_validation"
    extracted_val = None
    try:
        # 5. Validate Rule Execution (the 'rule')
        extracted_val = execute_rule(rule, text)

        # Special handling for conditional_null with None values
        if field_value is None:
            # Field is supposed to be null
            if extracted_val == "__NULL__":
                extra = {
                    "field": field_name,
                    "attempt": attempt,
                    "stage": stage,
                    "strategy": rule.strategy,
                    "extracted": "__NULL__",
                    "note": "Correctly identified null field",
                }
                logger.debug(
                    f"Extraction rule validation successful (null field): {extra}",
                )
                return None  # Success
            else:
                # Expected null but got something else
                feedback = (
                    f"- ATTEMPT {attempt} FAILED: Expected NULL field.\n"
                    f"  - Extracted: `{extracted_val}`\n"
                    f"  - Expected: NULL (no value)\n"
                    f"  - Your rule should use 'conditional_null' strategy "
                    f"to correctly detect null fields."
                )
                extra = {
                    "field": field_name,
                    "attempt": attempt,
                    "stage": stage,
                    "extracted": extracted_val,
                    "expected": "NULL",
                }
                logger.warning(
                    f"Extraction rule failed - expected null: {extra}",
                )
                return feedback

        # Normal case: field has a value
        if extracted_val == field_value:
            extra = {
                "field": field_name,
                "attempt": attempt,
                "stage": stage,
                "rule": rule.rule,
                "extracted": extracted_val,
            }
            logger.debug(
                f"Extraction rule validation successful: {extra}",
            )
            return None  # Success

        # Mismatch failure
        feedback = (
            f"- ATTEMPT {attempt} FAILED: The 'rule' was wrong. "
            f"Rule: `{rule.rule}`\n"
            f"  - Extracted: `{extracted_val}`\n"
            f"  - Expected: `{field_value}`\n"
            f"Please create a more precise regex."
        )
        extra = {
            "field": field_name,
            "attempt": attempt,
            "stage": stage,
            "rule": rule.rule,
            "extracted": extracted_val,
            "expected": field_value,
        }
        logger.warning(
            f"Extraction rule mismatch: {extra}",
        )
        return feedback

    except Exception as e:
        # Execution error
        feedback = (
            f"- ATTEMPT {attempt} FAILED: Error executing 'rule' regex. "
            f"Rule: `{rule.rule}`. Error: {e}"
        )
        extra = {
            "field": field_name,
            "attempt": attempt,
            "stage": stage,
            "rule": rule.rule,
            "error": str(e),
        }
        logger.warning(
            f"Extraction rule execution error: {extra}",
        )
        return feedback


def _validate_validation_regex(
    rule: Rule,
    field_value: str,
    field_name: str,
    attempt: int,
) -> Optional[str]:
    """Validate that validation_regex correctly matches the expected value.

    Special handling for conditional_null:
    - If field_value is None, validation_regex should match "__NULL__"
    - Otherwise, validation_regex should match the actual field_value
    """
    stage = "validation_regex_validation"
    try:
        # 6. Validate Validation Execution (the 'validation_regex')

        # For null fields, we need to validate against "__NULL__" marker
        value_to_validate = "__NULL__" if field_value is None else field_value

        if re.match(rule.validation_regex, value_to_validate):
            extra = {
                "field": field_name,
                "attempt": attempt,
                "stage": stage,
                "validation_regex": rule.validation_regex,
                "value_matched": value_to_validate,
            }
            logger.debug(
                f"Validation regex validation successful: {extra}",
            )
            return None  # Success

        # Mismatch failure
        feedback = (
            f"- ATTEMPT {attempt} FAILED: The 'validation_regex' was wrong.\n"
            f"  - Regex: `{rule.validation_regex}`\n"
            f"  - Did not match the expected value: `{value_to_validate}`\n"
            f"  - Please create a 'validation_regex' that fully matches "
            f"the expected value."
        )
        extra = {
            "field": field_name,
            "attempt": attempt,
            "stage": stage,
            "validation_regex": rule.validation_regex,
            "expected_to_match": value_to_validate,
        }
        logger.warning(
            f"Validation regex mismatch: {extra}",
        )
        return feedback

    except Exception as e:
        # Execution error
        feedback = (
            f"- ATTEMPT {attempt} FAILED: Error in 'validation_regex'. "
            f"Regex: `{rule.validation_regex}`. Error: {e}"
        )
        extra = {
            "field": field_name,
            "attempt": attempt,
            "stage": stage,
            "validation_regex": rule.validation_regex,
            "error": str(e),
        }
        logger.warning(
            f"Validation regex execution error: {extra}",
        )
        return feedback


def _validate_no_other_keywords(
    field_value: Optional[str],
    other_keywords: List[str],
    field_name: str,
    attempt: int,
) -> Optional[str]:
    """Check if the extracted value contains forbidden keywords from other fields.

    This guard rail ensures that the extracted value is not just another field's
    name/keyword, which would indicate an incorrect extraction rule.

    Special handling for None values:
    - If field_value is None, skip this validation (null fields can't be contaminated)
    """
    stage = "keyword_contamination_validation"

    # Skip validation for None values (null fields)
    if field_value is None:
        extra = {
            "field": field_name,
            "attempt": attempt,
            "stage": stage,
            "field_value": None,
            "note": "Skipping keyword validation for null field",
        }
        logger.debug(
            f"No keyword contamination check needed for null field: {extra}",
        )
        return None  # Success - no validation needed for null

    for keyword in other_keywords:
        # Check if the extracted value *is* or *contains* another keyword.
        # Using \b (word boundary) is robust.
        if re.search(r"\b" + re.escape(keyword) + r"\b", field_value, re.IGNORECASE):
            feedback = (
                f"- ATTEMPT {attempt} FAILED: The value '{field_value}' "
                f"is or contains a forbidden keyword: '{keyword}'. "
                f"This is incorrect. The 'rule' or 'validation_regex' is wrong."
            )
            extra = {
                "field": field_name,
                "attempt": attempt,
                "stage": stage,
                "field_value": field_value,
                "forbidden_keyword": keyword,
            }
            logger.warning(
                f"Keyword contamination detected: {extra}",
            )
            return feedback

    # Success - no forbidden keywords found
    extra = {
        "field": field_name,
        "attempt": attempt,
        "stage": stage,
        "field_value": field_value,
    }
    logger.debug(
        f"No keyword contamination detected: {extra}",
    )
    return None


def generate_robust_rule(
    agent_rule,
    text: str,
    field_name: str,
    field_value: str,
    field_description: str,
    all_fields: List[str],
    max_attempts: int = 3,
) -> tuple[Optional[Rule], int, int]:
    """Generate a robust extraction rule with validation.

    Returns:
        tuple: (rule, total_prompt_tokens, total_completion_tokens)
    """
    total_prompt_tokens = 0
    total_completion_tokens = 0

    extra = (
        {
            "field": field_name,
            "field_value": field_value,
        },
    )

    other_keywords = [fname for fname in all_fields if fname != field_name]

    # 1. Prepare the base prompt
    base_prompt = create_rule_generation_prompt(
        text, field_name, field_value, field_description, other_keywords
    )
    feedback_history: List[str] = []  # Stores feedback from failures

    for attempt in range(max_attempts):
        current_attempt = attempt + 1
        extra = (
            {
                "field": field_name,
                "current_attempt": current_attempt,
                "max_attempts": max_attempts,
            },
        )
        logger.info(
            f"Starting attempt {current_attempt}/{max_attempts} for field '{field_name}': {extra}"
        )

        # 2. Build the prompt with feedback (if any)
        current_prompt = base_prompt
        if feedback_history:
            # Join feedback neatly with separators
            feedback_str = "\n".join(feedback_history)

            # Append feedback section using f-string for clarity
            current_prompt += f"""
---
You have tried before. Analyze the feedback and generate a new rule.

### FEEDBACK FROM PREVIOUS ATTEMPTS ({len(feedback_history)} total):
{feedback_str}

Now, generate a **new and corrected** rule below:
"""

            # Collect debug info in a clear, single-line dict
            extra_info = {
                "attempt_number": current_attempt,
                "feedback_entries": len(feedback_history),
            }

            logger.debug(
                f"Added feedback context to prompt for attempt #{current_attempt}: {extra_info}"
            )

        # 3. Invoke Agent (LLM)
        extra = (
            {
                "current_attempt": current_attempt,
            },
        )
        try:
            response = agent_rule.invoke(
                {"messages": [{"role": "user", "content": current_prompt}]}
            )
        except Exception as e:
            logger.debug(
                f"Error invoking agent for rule generation on attempt {current_attempt} for field '{field_name}': {e}",
            )
            feedback = (
                f"- ATTEMPT {current_attempt} FAILED: Error invoking language model. "
                f"Error: {e}"
            )
            feedback_history.append(feedback)
            continue

        # Track token usage from this attempt
        ai_message = response["messages"][-1]
        if hasattr(ai_message, "response_metadata") and ai_message.response_metadata:
            if (
                "token_usage" in ai_message.response_metadata
                and ai_message.response_metadata["token_usage"]
            ):
                total_prompt_tokens += ai_message.response_metadata["token_usage"].get(
                    "prompt_tokens", 0
                )
                total_completion_tokens += ai_message.response_metadata[
                    "token_usage"
                ].get("completion_tokens", 0)

        # 4. Validate Syntax
        rule, feedback = _validate_syntax(response, field_name, current_attempt)
        if feedback:
            feedback_history.append(feedback)
            continue  # Try again

        # 5. Validate Rule Execution
        feedback = _validate_extraction_rule(
            rule, text, field_value, field_name, current_attempt
        )
        if feedback:
            feedback_history.append(feedback)
            continue  # Try again

        # 6. Validate Validation Regex
        feedback = _validate_validation_regex(
            rule, field_value, field_name, current_attempt
        )
        if feedback:
            feedback_history.append(feedback)
            continue  # Try again

        # 7. Validate No Other Keywords (Guard Rail)
        # Prepare other_keywords list (exclude current field name)
        feedback = _validate_no_other_keywords(
            field_value, other_keywords, field_name, current_attempt
        )
        if feedback:
            feedback_history.append(feedback)
            continue  # Try again

        # 8. Success!
        # All validations (Syntax, Rule, Validation, No Keywords) passed.
        extra = (
            {
                "field": field_name,
                "final_attempt": current_attempt,
                "final_feedback_history": "\n".join(feedback_history),
            },
        )
        logger.info(
            f"Rule generation successful for field '{field_name}' after {current_attempt} attempts: {extra}",
        )
        return rule, total_prompt_tokens, total_completion_tokens

    # 9. Failure (after max_attempts)
    extra = (
        {
            "field": field_name,
            "attempts": max_attempts,
            "final_feedback_history": "\n".join(feedback_history),
        },
    )
    logger.error(
        f"Failed to generate a valid rule for field '{field_name}' after {max_attempts} attempts: {extra}",
    )
    print(f"ALERT: Failed to generate a valid rule for field '{field_name}'.")
    return None, total_prompt_tokens, total_completion_tokens
