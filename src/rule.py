"""Rule definition, execution, generation, and validation.

This module contains everything related to extraction rules:
- Rule model and types
- Rule execution (_execute_regex, _execute_keyword, etc.)
- Rule generation with feedback loop
- Rule validation functions
- Prompt templates
"""

import re
from typing import Any, Dict, List, Literal, Optional, Tuple

from pydantic import BaseModel, Field

from logger import get_logger

logger = get_logger(name=__name__)


# ============================================================================
# SECTION 1: Rule Model & Types
# ============================================================================

# Define the exact types of rules that your system understands
RuleType = Literal["regex", "keyword", "position"]

# Define the exact strategies for rules of type "keyword"
KeywordStrategy = Literal["next_line", "multiline_until_stop", "conditional_null"]


class Rule(BaseModel):
    """Stores a single extraction rule generated by the Learning Loop."""

    type: RuleType = Field(
        ..., description="The main type of the rule (regex, keyword, or position)"
    )

    rule: Optional[str] = Field(
        None,
        description=r"The regex pattern to be executed. (Ex: 'Inscrição[^\d]*(\d{6})')",
    )

    keyword: Optional[str] = Field(
        None, description="The 'anchor' keyword to search for in the text."
    )

    strategy: Optional[KeywordStrategy] = Field(
        None, description="The action to take after finding the keyword."
    )

    stop_keyword: Optional[str] = Field(
        None,
        description="Where to stop for 'multiline' or what to check for 'conditional'.",
    )

    line_number: Optional[int] = Field(
        None,
        description="The line number to extract (e.g., 1 for the first line).",
    )

    validation_regex: str = Field(
        ...,
        description=r"A simple regex to validate the *format* of the extracted value (e.g., '^\d{6}$').",
    )

    def apply(self, text: Optional[str]) -> Optional[str]:
        """Applies this rule to the given text and returns the extracted value."""
        if not text:
            return None
        try:
            return execute_rule(self, text)
        except Exception as e:
            logger.error(f"Error applying rule: {e}")
            return None

    def validate(self, text: Optional[str]) -> bool:
        """Validates the text against the validation regex.

        Special handling for __NULL__ marker from conditional_null strategy:
        - If text is "__NULL__", it should match a validation_regex for null values
        - For non-null values, the regex should NOT match "__NULL__"
        """
        if not text:
            return False
        try:
            return re.match(self.validation_regex, text) is not None
        except Exception as e:
            logger.error(f"Error validating text: {e}")
            return False


# ============================================================================
# SECTION 2: Rule Execution
# ============================================================================


def execute_rule(rule: Rule, text: str) -> Optional[str]:
    """Executes a given extraction rule on the input text.

    This function acts as a dispatcher, calling the correct
    sub-function based on the rule's 'type'.
    """
    try:
        if rule.type == "regex":
            return _execute_regex_rule(rule, text)
        elif rule.type == "keyword":
            return _execute_keyword_rule(rule, text)
        elif rule.type == "position":
            return _execute_position_rule(rule, text)
    except Exception as e:
        # Catch any unexpected errors during rule execution
        logger.error(
            f"Error executing rule (type: {rule.type}, rule: {rule.rule}): {e}"
        )
        return None

    return None


def _execute_regex_rule(rule: Rule, text: str) -> Optional[str]:
    """Applies a 'regex' type rule."""
    if not rule.rule:
        return None

    # re.DOTALL makes the '.' special character match any character,
    # including a newline. This is crucial for multi-line fields.
    match = re.search(rule.rule, text, re.DOTALL)

    if match:
        try:
            # .group(1) extracts the text from the *first capture group*
            # This is the standard for extraction regex.
            return match.group(1).strip()
        except IndexError:
            # This happens if the regex matched but had NO capture group.
            # We can fall back to group(0), the full match.
            return match.group(0).strip()

    return None  # No match found


def _execute_keyword_rule(rule: Rule, text: str) -> Optional[str]:
    """Applies a 'keyword' type rule.

    Special behavior for 'conditional_null' strategy:
    - Returns "__NULL__" when field is genuinely null (empty between keywords)
    - Returns None when rule doesn't match (has value or stop_keyword not found)
    """
    if not rule.keyword:
        return None

    # Find the keyword
    keyword_pos = text.find(rule.keyword)
    if keyword_pos == -1:
        logger.info(
            "Keyword rule: keyword '%s' not found in text. Impossible to extract value. Returning None.",
            rule.keyword,
        )
        return "__NULL__"

    # Get all text *after* the keyword
    start_pos = keyword_pos + len(rule.keyword)
    text_after = text[start_pos:]

    # --- Apply Strategy ---

    if rule.strategy == "next_line":
        # Finds the first non-empty line after the keyword
        for line in text_after.splitlines():
            stripped_line = line.strip()
            if stripped_line:
                return stripped_line
        return None  # No non-empty line found

    elif rule.strategy == "multiline_until_stop":
        if not rule.stop_keyword:
            return text_after.strip()  # No stop, return all text after

        # Find the stop_keyword *in the text after the keyword*
        stop_pos = text_after.find(rule.stop_keyword)

        if stop_pos != -1:
            # Return everything between keyword and stop_keyword
            return text_after[:stop_pos].strip()
        else:
            # Stop keyword wasn't found, so this rule fails
            return None

    elif rule.strategy == "conditional_null":
        # This strategy checks if a field is genuinely null/empty
        # by verifying only whitespace exists between this keyword
        # and the next field's keyword (or end of text for last field)

        if rule.stop_keyword:
            # If we have a stop_keyword, check the region between keywords
            stop_pos = text_after.find(rule.stop_keyword)

            if stop_pos == -1:
                # Stop keyword not found - this rule doesn't match
                # (the next field's keyword should always be present)
                logger.warning(
                    "conditional_null FAILED: stop_keyword '%s' not found in text after keyword '%s'. ",
                    rule.stop_keyword,
                    rule.keyword,
                )
                return None

            # Get text between the two keywords
            between_text = text_after[:stop_pos]
            logger.debug(
                "conditional_null: checking region between '%s' and '%s'",
                rule.keyword,
                rule.stop_keyword,
            )
        else:
            # No stop_keyword specified - this is the last field
            # Check from keyword to end of text
            between_text = text_after
            logger.debug(
                "conditional_null: no stop_keyword specified, checking to end of text"
            )

        # Check if there's only whitespace in the region
        if not between_text.strip():
            # Success! The field is genuinely null (empty)
            if rule.stop_keyword and text_after.find(rule.stop_keyword) != -1:
                logger.debug(
                    "conditional_null: Field is NULL - only whitespace between '%s' and '%s'",
                    rule.keyword,
                    rule.stop_keyword,
                )
            else:
                logger.debug(
                    "conditional_null: Field is NULL - only whitespace after '%s' (last field)",
                    rule.keyword,
                )
            return "__NULL__"  # Special marker indicating genuine null
        else:
            # Failure - there's actual content in the region
            # This means the field has a value, so this null-detection rule doesn't match
            logger.warning(
                "conditional_null FAILED: Field has value (not null). "
                "Keyword: '%s', Stop: '%s'",
                rule.keyword,
                rule.stop_keyword,
            )
            return None

    return None


def _execute_position_rule(rule: Rule, text: str) -> Optional[str]:
    """Applies a 'position' type rule."""
    if not rule.line_number or rule.line_number <= 0:
        return None  # Invalid line number

    lines = text.splitlines()

    # -1 because line_number is 1-based, list is 0-based
    line_index = rule.line_number - 1

    if line_index < len(lines):
        return lines[line_index].strip()

    return None  # Line number out of range


# ============================================================================
# SECTION 3: Rule Generation
# ============================================================================


def generate_robust_rule(
    agent_rule,
    text: str,
    field_name: str,
    field_value: str,
    field_description: str,
    all_fields: List[str],
    max_attempts: int = 3,
) -> tuple[Optional[Rule], int, int]:
    """Generate a robust extraction rule with validation and feedback loop.

    Args:
        agent_rule: LangChain agent for rule generation
        text: Input text to extract from
        field_name: Name of the field to extract
        field_value: Expected value for validation
        field_description: Description of what the field contains
        all_fields: List of all field names (for keyword contamination check)
        max_attempts: Maximum number of generation attempts

    Returns:
        tuple: (rule, total_prompt_tokens, total_completion_tokens)
               rule will be None if generation fails after max_attempts
    """
    total_prompt_tokens = 0
    total_completion_tokens = 0
    llm2_calls = 0

    other_keywords = [fname for fname in all_fields if fname != field_name]

    # 1. Prepare the base prompt
    base_prompt = create_rule_generation_prompt(
        text, field_name, field_value, field_description, other_keywords
    )
    feedback_history: List[str] = []  # Stores feedback from failures

    for attempt in range(max_attempts):
        current_attempt = attempt + 1
        logger.info(
            "Starting attempt %d/%d for field '%s'",
            current_attempt,
            max_attempts,
            field_name,
        )

        # 2. Build the prompt with feedback (if any)
        current_prompt = base_prompt
        if feedback_history:
            feedback_str = "\n".join(feedback_history)
            current_prompt += f"""
---
You have tried before. Analyze the feedback and generate a new rule.

### FEEDBACK FROM PREVIOUS ATTEMPTS ({len(feedback_history)} total):
{feedback_str}

Now, generate a **new and corrected** rule below:
"""
            logger.debug(
                "Added feedback context (%d entries) to prompt for attempt #%d",
                len(feedback_history),
                current_attempt,
            )

        # 3. Invoke Agent (LLM)
        try:
            response = agent_rule.invoke(
                {"messages": [{"role": "user", "content": current_prompt}]}
            )
            llm2_calls += 1
        except Exception as e:
            logger.warning(
                "Error invoking agent for rule generation on attempt %d for field '%s': %s",
                current_attempt,
                field_name,
                e,
            )
            feedback = (
                f"- ATTEMPT {current_attempt} FAILED: Error invoking language model. "
                f"Error: {e}"
            )
            feedback_history.append(feedback)
            continue

        # Track token usage from this attempt
        ai_message = response["messages"][-1]
        if hasattr(ai_message, "response_metadata") and ai_message.response_metadata:
            if (
                "token_usage" in ai_message.response_metadata
                and ai_message.response_metadata["token_usage"]
            ):
                total_prompt_tokens += ai_message.response_metadata["token_usage"].get(
                    "prompt_tokens", 0
                )
                total_completion_tokens += ai_message.response_metadata[
                    "token_usage"
                ].get("completion_tokens", 0)

        # 4. Validate Syntax
        rule, feedback = _validate_syntax(response, field_name, current_attempt)
        if feedback:
            feedback_history.append(feedback)
            continue  # Try again

        # 5. Validate Rule Execution
        feedback = _validate_extraction_rule(
            rule, text, field_value, field_name, current_attempt
        )
        if feedback:
            feedback_history.append(feedback)
            continue  # Try again

        # 6. Validate Validation Regex
        feedback = _validate_validation_regex(
            rule, field_value, field_name, current_attempt
        )
        if feedback:
            feedback_history.append(feedback)
            continue  # Try again

        # 7. Validate No Other Keywords (Guard Rail)
        feedback = _validate_no_other_keywords(
            field_value, other_keywords, field_name, current_attempt
        )
        if feedback:
            feedback_history.append(feedback)
            continue  # Try again

        # 8. Success! All validations passed
        logger.info(
            "Rule generation successful for field '%s' after %d attempt(s)",
            field_name,
            current_attempt,
        )
        return rule, total_prompt_tokens, total_completion_tokens, llm2_calls

    # 9. Failure (after max_attempts)
    logger.error(
        "Failed to generate valid rule for field '%s' after %d attempts",
        field_name,
        max_attempts,
    )
    return None, total_prompt_tokens, total_completion_tokens, llm2_calls


# ============================================================================
# SECTION 4: Rule Validation
# ============================================================================


def _validate_syntax(
    response: Dict[str, Any],
    field_name: str,
    attempt: int,
) -> Tuple[Optional[Rule], Optional[str]]:
    """Validate rule syntax and schema.

    Returns:
        Tuple of (Rule, feedback_message)
        - If successful: (Rule object, None)
        - If failed: (None, error message)
    """
    stage = "syntax_validation"
    try:
        rule = Rule.model_validate(response.get("structured_response", {}))
        logger.debug(
            "Syntax validation successful for field '%s' attempt %d",
            field_name,
            attempt,
        )
        return rule, None
    except Exception as e:
        feedback = (
            f"- ATTEMPT {attempt} FAILED: The JSON was malformed or failed schema validation. "
            f"Error: {e}. Make sure to return ONLY valid JSON matching the schema."
        )
        logger.warning(
            "Syntax validation failed for field '%s' attempt %d: %s",
            field_name,
            attempt,
            e,
        )
        return None, feedback


def _validate_extraction_rule(
    rule: Rule,
    text: str,
    field_value: str,
    field_name: str,
    attempt: int,
) -> Optional[str]:
    """Validate that the rule extracts the expected value.

    Special handling for conditional_null strategy:
    - If field_value is None, expect rule to return "__NULL__"
    - If field_value is not None, rule should NOT return "__NULL__"

    Returns:
        None if validation passes, error message string if validation fails
    """
    stage = "extraction_validation"
    extracted_val = None
    try:
        extracted_val = execute_rule(rule, text)

        # Special handling for conditional_null with None values
        if field_value is None:
            # Field is supposed to be null
            if extracted_val == "__NULL__":
                logger.debug(
                    "Extraction rule correctly identified null field '%s' (attempt %d)",
                    field_name,
                    attempt,
                )
                return None  # Success
            else:
                feedback = (
                    f"- ATTEMPT {attempt} FAILED\n"
                    f"  - This means your 'conditional_null' rule didn't match.\n"
                    f"  - Possible reasons:\n"
                    f"    1. The 'keyword' ('{rule.keyword}') was not found in the text\n"
                    f"    2. The 'stop_keyword' ('{rule.stop_keyword}') was not found after the keyword\n"
                    f"    3. There is actual content between the keywords (field is not null)\n"
                    f"  - Rule details: keyword='{rule.keyword}', stop_keyword='{rule.stop_keyword}'"
                )
                logger.warning(
                    "Extraction rule failed for field '%s' (attempt %d) - expected null, got '%s'",
                    field_name,
                    attempt,
                    extracted_val,
                )
                return feedback

        # Normal case: field has a value
        if extracted_val == field_value:
            logger.debug(
                "Extraction rule validation successful for field '%s' (attempt %d)",
                field_name,
                attempt,
            )
            return None  # Success

        # Mismatch failure
        feedback = (
            f"- ATTEMPT {attempt} FAILED: The 'rule' was wrong. "
            f"Rule: `{rule.rule}`\n"
            f"  - Extracted: `{extracted_val}`\n"
            f"  - Expected: `{field_value}`\n"
            f"Please create a more precise regex."
        )
        logger.warning(
            "Extraction rule mismatch for field '%s' (attempt %d): extracted '%s', expected '%s'",
            field_name,
            attempt,
            extracted_val,
            field_value,
        )
        return feedback

    except Exception as e:
        # Execution error
        feedback = (
            f"- ATTEMPT {attempt} FAILED: Error executing 'rule' regex. "
            f"Rule: `{rule.rule}`. Error: {e}"
        )
        logger.warning(
            "Extraction rule execution error for field '%s' (attempt %d): %s",
            field_name,
            attempt,
            e,
        )
        return feedback


def _validate_validation_regex(
    rule: Rule,
    field_value: str,
    field_name: str,
    attempt: int,
) -> Optional[str]:
    """Validate that validation_regex correctly matches the expected value.

    Special handling for conditional_null:
    - If field_value is None, validation_regex should match "__NULL__"
    - Otherwise, validation_regex should match the actual field_value

    Returns:
        None if validation passes, error message string if validation fails
    """
    stage = "validation_regex_validation"
    try:
        # For null fields, we need to validate against "__NULL__" marker
        value_to_validate = "__NULL__" if field_value is None else field_value

        if re.match(rule.validation_regex, value_to_validate):
            logger.debug(
                "Validation regex successful for field '%s' (attempt %d)",
                field_name,
                attempt,
            )
            return None  # Success

        # Mismatch failure
        feedback = (
            f"- ATTEMPT {attempt} FAILED: The 'validation_regex' was wrong.\n"
            f"  - Regex: `{rule.validation_regex}`\n"
            f"  - Did not match the expected value: `{value_to_validate}`\n"
            f"  - Please create a 'validation_regex' that fully matches "
            f"the expected value."
        )
        logger.warning(
            "Validation regex mismatch for field '%s' (attempt %d): regex '%s' did not match '%s'",
            field_name,
            attempt,
            rule.validation_regex,
            value_to_validate,
        )
        return feedback

    except Exception as e:
        # Execution error
        feedback = (
            f"- ATTEMPT {attempt} FAILED: Error in 'validation_regex'. "
            f"Regex: `{rule.validation_regex}`. Error: {e}"
        )
        logger.warning(
            "Validation regex execution error for field '%s' (attempt %d): %s",
            field_name,
            attempt,
            e,
        )
        return feedback


def _validate_no_other_keywords(
    field_value: Optional[str],
    other_keywords: List[str],
    field_name: str,
    attempt: int,
) -> Optional[str]:
    """Check if the extracted value contains forbidden keywords from other fields.

    This guard rail ensures that the extracted value is not just another field's
    name/keyword, which would indicate an incorrect extraction rule.

    Special handling for None values:
    - If field_value is None, skip this validation (null fields can't be contaminated)

    Returns:
        None if validation passes, error message string if validation fails
    """
    stage = "keyword_contamination_validation"

    # Skip validation for None values (null fields)
    if field_value is None:
        logger.debug(
            "Skipping keyword contamination check for null field '%s' (attempt %d)",
            field_name,
            attempt,
        )
        return None  # Success - no validation needed for null

    for keyword in other_keywords:
        # Check if the extracted value *is* or *contains* another keyword.
        # Using \b (word boundary) is robust.
        if re.search(r"\b" + re.escape(keyword) + r"\b", field_value, re.IGNORECASE):
            feedback = (
                f"- ATTEMPT {attempt} FAILED: The value '{field_value}' "
                f"is or contains a forbidden keyword: '{keyword}'. "
                f"This is incorrect. The 'rule' or 'validation_regex' is wrong."
            )
            logger.warning(
                "Keyword contamination detected for field '%s' (attempt %d): value '%s' contains keyword '%s'",
                field_name,
                attempt,
                field_value,
                keyword,
            )
            return feedback

    # Success - no forbidden keywords found
    logger.debug(
        "No keyword contamination detected for field '%s' (attempt %d)",
        field_name,
        attempt,
    )
    return None


# ============================================================================
# SECTION 5: Prompt Templates
# ============================================================================


def create_rule_generation_prompt(
    text: str,
    field_name: str,
    field_value: str,
    field_description: str,
    other_keywords: List[str],
) -> str:
    """Create rule generation prompt from the imported template.

    This function will use the RULE_GENERATION_PROMPT from llm.py
    once imports are updated.
    """
    # Import from llm module after refactoring is complete
    from llm import RULE_GENERATION_PROMPT

    return RULE_GENERATION_PROMPT.format(
        text=text,
        field_name=field_name,
        field_value=field_value,
        field_description=field_description,
        other_keywords=other_keywords,
    )
