"""Rule definition, execution, generation, and validation.

This module contains everything related to extraction rules:
- Rule model and types
- Rule execution (regex only)
- Rule generation with feedback loop
- Rule validation functions
- Prompt templates
"""

import re
from typing import Any, Dict, List, Optional, Tuple

from pydantic import BaseModel, Field

from llm import RULE_GENERATION_PROMPT
from logger import get_logger

logger = get_logger(name=__name__)


# ============================================================================
# SECTION 1: Rule Model & Types
# ============================================================================


class Rule(BaseModel):
    """Stores a single extraction rule generated by the Learning Loop."""

    rule: str = Field(
        ...,
        description=r"The regex pattern to be executed. "
        r"(Ex: 'Inscrição[^\d]*(\d{6})')",
    )

    validation_regex: str = Field(
        ...,
        description=r"A simple regex to validate the *format* of the "
        r"extracted value (e.g., '^\d{6}$' or '^$' for empty strings).",
    )

    def apply(self, text: Optional[str]) -> Optional[str]:
        """Applies this rule to the given text and returns the extracted value."""
        if not text:
            return None
        try:
            return execute_rule(self, text)
        except Exception as e:
            logger.error(f"Error applying rule: {e}")
            return None

    def validate(self, text: Optional[str]) -> bool:
        """Validates the text against the validation regex.

        Empty strings are considered valid if they match the validation_regex.
        """
        if text is None:
            return False
        try:
            return re.match(self.validation_regex, text) is not None
        except Exception as e:
            logger.error(f"Error validating text: {e}")
            return False


# ============================================================================
# SECTION 2: Rule Execution
# ============================================================================


def execute_rule(rule: Rule, text: str) -> Optional[str]:
    """Executes a regex extraction rule on the input text.

    Returns:
        Extracted value as string, or empty string "" if pattern matches
        but captures nothing (for null fields), or None if no match.
    """
    try:
        if not rule.rule:
            return None

        match = re.search(rule.rule, text, re.DOTALL)

        if match:
            try:
                captured = match.group(1).strip()
                # Return empty string if captured text is empty (null fields)
                return captured if captured else ""
            except IndexError:
                # captured = match.group(0).strip()
                # return captured if captured else ""
                return None

        return None  # No match found

    except Exception as e:
        # Catch any unexpected errors during rule execution
        logger.error(f"Error executing rule (rule: {rule.rule}): {e}")
        return None


# ============================================================================
# SECTION 3: Rule Generation
# ============================================================================


def generate_robust_rule(
    agent_rule,
    text: str,
    field_name: str,
    field_value: Optional[str],
    field_description: str,
    all_fields: List[str],
    max_attempts: int = 3,
) -> tuple[Optional[Rule], int, int, int]:
    """Generate a robust extraction rule with validation and feedback loop.

    Args:
        agent_rule: LangChain agent for rule generation
        text: Input text to extract from
        field_name: Name of the field to extract
        field_value: Expected value for validation (None becomes "")
        field_description: Description of what the field contains
        all_fields: List of all field names (for keyword contamination check)
        max_attempts: Maximum number of generation attempts

    Returns:
        tuple: (rule, total_prompt_tokens, total_completion_tokens, llm2_calls)
               rule will be None if generation fails after max_attempts
    """
    total_prompt_tokens = 0
    total_completion_tokens = 0
    llm2_calls = 0

    # Convert None to empty string for null fields
    expected_value = "" if field_value is None else field_value

    other_keywords = [fname for fname in all_fields if fname != field_name]

    # 1. Prepare the base prompt
    base_prompt = create_rule_generation_prompt(
        text, field_name, expected_value, field_description, other_keywords
    )
    feedback_history: List[str] = []  # Stores feedback from failures

    for attempt in range(max_attempts):
        current_attempt = attempt + 1
        logger.info(
            "Starting attempt %d/%d for field '%s'",
            current_attempt,
            max_attempts,
            field_name,
        )

        # 2. Build the prompt with feedback (if any)
        current_prompt = base_prompt
        if feedback_history:
            feedback_str = "\n".join(feedback_history)
            current_prompt += f"""
---
You have tried before. Analyze the feedback and generate a new rule.

### FEEDBACK FROM PREVIOUS ATTEMPTS ({len(feedback_history)} total):
{feedback_str}

Now, generate a **new and corrected** rule below:
"""
            logger.debug(
                "Added feedback context (%d entries) to prompt for attempt #%d",
                len(feedback_history),
                current_attempt,
            )

        # 3. Invoke Agent (LLM)
        try:
            response = agent_rule.invoke(
                {"messages": [{"role": "user", "content": current_prompt}]}
            )
            llm2_calls += 1
        except Exception as e:
            logger.warning(
                "Error invoking agent for rule generation on attempt %d "
                "for field '%s': %s",
                current_attempt,
                field_name,
                e,
            )
            feedback = (
                f"- ATTEMPT {current_attempt} FAILED: Error invoking "
                f"language model. Error: {e}"
            )
            feedback_history.append(feedback)
            continue

        # Track token usage from this attempt
        ai_message = response["messages"][-1]
        if hasattr(ai_message, "response_metadata") and ai_message.response_metadata:
            if (
                "token_usage" in ai_message.response_metadata
                and ai_message.response_metadata["token_usage"]
            ):
                total_prompt_tokens += ai_message.response_metadata["token_usage"].get(
                    "prompt_tokens", 0
                )
                total_completion_tokens += ai_message.response_metadata[
                    "token_usage"
                ].get("completion_tokens", 0)

        # 4. Validate Syntax
        rule, feedback = _validate_syntax(response, field_name, current_attempt)
        if feedback:
            feedback_history.append(feedback)
            continue  # Try again

        # 5. Validate Rule Execution
        feedback = _validate_extraction_rule(
            rule, text, expected_value, field_name, current_attempt
        )
        if feedback:
            feedback_history.append(feedback)
            continue  # Try again

        # 6. Validate Validation Regex
        feedback = _validate_validation_regex(
            rule, expected_value, field_name, current_attempt
        )
        if feedback:
            feedback_history.append(feedback)
            continue  # Try again

        # 7. Validate No Other Keywords (Guard Rail)
        feedback = _validate_no_other_keywords(
            expected_value, other_keywords, field_name, current_attempt
        )
        if feedback:
            feedback_history.append(feedback)
            continue  # Try again

        # 8. Success! All validations passed
        logger.info(
            "Rule generation successful for field '%s' after %d attempt(s)",
            field_name,
            current_attempt,
        )
        return rule, total_prompt_tokens, total_completion_tokens, llm2_calls

    # 9. Failure (after max_attempts)
    logger.error(
        "Failed to generate valid rule for field '%s' after %d attempts",
        field_name,
        max_attempts,
    )
    return None, total_prompt_tokens, total_completion_tokens, llm2_calls


# ============================================================================
# SECTION 4: Rule Validation
# ============================================================================


def _validate_syntax(
    response: Dict[str, Any],
    field_name: str,
    attempt: int,
) -> Tuple[Optional[Rule], Optional[str]]:
    """Validate rule syntax and schema.

    Returns:
        Tuple of (Rule, feedback_message)
        - If successful: (Rule object, None)
        - If failed: (None, error message)
    """
    try:
        rule = Rule.model_validate(response.get("structured_response", {}))
        logger.debug(
            "Syntax validation successful for field '%s' attempt %d",
            field_name,
            attempt,
        )
        return rule, None
    except Exception as e:
        feedback = (
            f"- ATTEMPT {attempt} FAILED: The JSON was malformed or "
            f"failed schema validation. Error: {e}. Make sure to return "
            f"ONLY valid JSON matching the schema."
        )
        logger.warning(
            "Syntax validation failed for field '%s' attempt %d: %s",
            field_name,
            attempt,
            e,
        )
        return None, feedback


def _validate_extraction_rule(
    rule: Rule,
    text: str,
    field_value: str,
    field_name: str,
    attempt: int,
) -> Optional[str]:
    """Validate that the rule extracts the expected value.

    field_value is expected to be "" for null fields (already converted).

    Returns:
        None if validation passes, error message string if validation fails
    """
    extracted_val = None
    try:
        extracted_val = execute_rule(rule, text)

        # Check if extracted value matches expected value
        if extracted_val == field_value:
            logger.debug(
                "Extraction rule validation successful for field '%s' (attempt %d)",
                field_name,
                attempt,
            )
            return None  # Success

        # Mismatch failure
        feedback = (
            f"- ATTEMPT {attempt} FAILED: The 'rule' was wrong. "
            f"Rule: `{rule.rule}`\n"
            f"  - Extracted: `{extracted_val}`\n"
            f"  - Expected: `{field_value}`\n"
            f"Please create a more precise regex."
        )
        logger.warning(
            "Extraction rule mismatch for field '%s' (attempt %d): "
            "extracted '%s', expected '%s'",
            field_name,
            attempt,
            extracted_val,
            field_value,
        )
        return feedback

    except Exception as e:
        # Execution error
        feedback = (
            f"- ATTEMPT {attempt} FAILED: Error executing 'rule' regex. "
            f"Rule: `{rule.rule}`. Error: {e}"
        )
        logger.warning(
            "Extraction rule execution error for field '%s' (attempt %d): %s",
            field_name,
            attempt,
            e,
        )
        return feedback


def _validate_validation_regex(
    rule: Rule,
    field_value: str,
    field_name: str,
    attempt: int,
) -> Optional[str]:
    """Validate that validation_regex correctly matches the expected value.

    field_value is expected to be "" for null fields (already converted).

    Returns:
        None if validation passes, error message string if validation fails
    """
    try:
        if re.match(rule.validation_regex, field_value):
            logger.debug(
                "Validation regex successful for field '%s' (attempt %d)",
                field_name,
                attempt,
            )
            return None  # Success

        # Mismatch failure
        feedback = (
            f"- ATTEMPT {attempt} FAILED: The 'validation_regex' was wrong.\n"
            f"  - Regex: `{rule.validation_regex}`\n"
            f"  - Did not match the expected value: `{field_value}`\n"
            f"  - Please create a 'validation_regex' that fully matches "
            f"the expected value."
        )
        logger.warning(
            "Validation regex mismatch for field '%s' (attempt %d): "
            "regex '%s' did not match '%s'",
            field_name,
            attempt,
            rule.validation_regex,
            field_value,
        )
        return feedback

    except Exception as e:
        # Execution error
        feedback = (
            f"- ATTEMPT {attempt} FAILED: Error in 'validation_regex'. "
            f"Regex: `{rule.validation_regex}`. Error: {e}"
        )
        logger.warning(
            "Validation regex execution error for field '%s' (attempt %d): %s",
            field_name,
            attempt,
            e,
        )
        return feedback


def _validate_no_other_keywords(
    field_value: str,
    other_keywords: List[str],
    field_name: str,
    attempt: int,
) -> Optional[str]:
    """Check if the extracted value contains forbidden keywords.

    This guard rail ensures that the extracted value is not just another
    field's name/keyword, which would indicate an incorrect extraction rule.

    Skip validation for empty strings (null fields).

    Returns:
        None if validation passes, error message string if validation fails
    """
    # Skip validation for empty strings (null fields)
    if field_value == "":
        logger.debug(
            "Skipping keyword contamination check for null field '%s' (attempt %d)",
            field_name,
            attempt,
        )
        return None  # Success - no validation needed for null

    for keyword in other_keywords:
        # Check if the extracted value *is* or *contains* another keyword.
        # Using \b (word boundary) is robust.
        pattern = r"\b" + re.escape(keyword) + r"\b"
        if re.search(pattern, field_value, re.IGNORECASE):
            feedback = (
                f"- ATTEMPT {attempt} FAILED: The value '{field_value}' "
                f"is or contains a forbidden keyword: '{keyword}'. "
                f"This is incorrect. The 'rule' or 'validation_regex' "
                f"is wrong."
            )
            logger.warning(
                "Keyword contamination detected for field '%s' (attempt %d): "
                "value '%s' contains keyword '%s'",
                field_name,
                attempt,
                field_value,
                keyword,
            )
            return feedback

    # Success - no forbidden keywords found
    logger.debug(
        "No keyword contamination detected for field '%s' (attempt %d)",
        field_name,
        attempt,
    )
    return None


# ============================================================================
# SECTION 5: Prompt Templates
# ============================================================================


def create_rule_generation_prompt(
    text: str,
    field_name: str,
    field_value: str,
    field_description: str,
    other_keywords: List[str],
) -> str:
    """Create rule generation prompt from the imported template.

    This function uses the RULE_GENERATION_PROMPT from llm.py.
    """
    return RULE_GENERATION_PROMPT.format(
        text=text,
        field_name=field_name,
        field_value=field_value,
        field_description=field_description,
        other_keywords=other_keywords,
    )
