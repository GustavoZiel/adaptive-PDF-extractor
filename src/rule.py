import logging
import re
from typing import Any, Dict, List, Literal, Optional, Tuple

from pydantic import BaseModel, Field

from logger import get_logger
from models import rule_generation_prompt_template_en

logger = get_logger(name=__name__)

# Define the exact types of rules that your system understands
RuleType = Literal["regex", "keyword", "position"]

# Define the exact strategies for rules of type "keyword"
KeywordStrategy = Literal["next_line", "multiline_until_stop", "conditional_null"]


class Rule(BaseModel):
    """Stores a single extraction rule generated by the Learning Loop."""

    type: RuleType = Field(
        ..., description="The main type of the rule (regex, keyword, or position)"
    )

    rule: Optional[str] = Field(
        None,
        description=r"The regex pattern to be executed. (Ex: 'Inscrição[^\d]*(\d{6})')",
    )

    keyword: Optional[str] = Field(
        None, description="The 'anchor' keyword to search for in the text."
    )

    strategy: Optional[KeywordStrategy] = Field(
        None, description="The action to take after finding the keyword."
    )

    stop_keyword: Optional[str] = Field(
        None,
        description="Where to stop for 'multiline' or what to check for 'conditional'.",
    )

    line_number: Optional[int] = Field(
        None,
        description="The line number to extract (e.g., 1 for the first line).",
    )

    validation_regex: str = Field(
        ...,
        description=r"A simple regex to validate the *format* of the extracted value (e.g., '^\d{6}$').",
    )

    def apply(self, text: Optional[str]) -> Optional[str]:
        """Applies this rule to the given text and returns the extracted value."""
        if not text:
            return None
        try:
            return execute_rule(self, text)
        except Exception as e:
            logger.error(f"Error applying rule: {e}")
            return None

    def validate(self, text: Optional[str]) -> bool:
        """Validates the text against the validation regex."""
        if not text:
            return False
        try:
            return re.match(self.validation_regex, text) is not None
        except Exception as e:
            logger.error(f"Error validating text: {e}")
            return False


def create_rule_generation_prompt(
    text: str,
    field_name: str,
    field_value: str,
    field_description: str,
    all_fields: List[str],
) -> str:
    other_keywords = ", ".join(
        [f"'{fname}'" for fname in all_fields if fname != field_name]
    )
    return rule_generation_prompt_template_en.format(
        text=text,
        field_name=field_name,
        field_value=field_value,
        field_description=field_description,
        other_keywords=other_keywords,
    )


def _execute_position_rule(rule: Rule, text: str) -> Optional[str]:
    """Applies a 'position' type rule."""
    if not rule.line_number or rule.line_number <= 0:
        return None  # Invalid line number

    lines = text.splitlines()

    # -1 because line_number is 1-based, list is 0-based
    line_index = rule.line_number - 1

    if line_index < len(lines):
        return lines[line_index].strip()

    return None  # Line number out of range


def _execute_keyword_rule(rule: Rule, text: str) -> Optional[str]:
    """Applies a 'keyword' type rule."""
    if not rule.keyword:
        return None

    # Find the keyword
    keyword_pos = text.find(rule.keyword)
    if keyword_pos == -1:
        return None  # Keyword not found

    # Get all text *after* the keyword
    start_pos = keyword_pos + len(rule.keyword)
    text_after = text[start_pos:]

    # --- Apply Strategy ---

    if rule.strategy == "next_line":
        # Finds the first non-empty line after the keyword
        for line in text_after.splitlines():
            stripped_line = line.strip()
            if stripped_line:
                return stripped_line
        return None  # No non-empty line found

    elif rule.strategy == "multiline_until_stop":
        if not rule.stop_keyword:
            return text_after.strip()  # No stop, return all text after

        # Find the stop_keyword *in the text after the keyword*
        stop_pos = text_after.find(rule.stop_keyword)

        if stop_pos != -1:
            # Return everything between keyword and stop_keyword
            return text_after[:stop_pos].strip()
        else:
            # Stop keyword wasn't found, so this rule fails
            return None

    elif rule.strategy == "conditional_null":
        # This rule's job is to confirm a value is null.
        # It succeeds *if* the text between keyword and stop_keyword is empty.
        if not rule.stop_keyword:
            return None  # This strategy requires a stop_keyword

        # Check if the text immediately after the keyword (when stripped)
        # starts with the stop_keyword.
        if text_after.strip().startswith(rule.stop_keyword):
            return None  # Success: The value is correctly identified as null.
        else:
            # Failure: There is text between the keywords.
            # This rule's logic does not match.
            return None

    return None


# (Assumes your Rule, RuleType, and KeywordStrategy models are defined)
def _execute_regex_rule(rule: Rule, text: str) -> Optional[str]:
    """Applies a 'regex' type rule."""
    if not rule.rule:
        return None

    # re.DOTALL makes the '.' special character match any character,
    # including a newline. This is crucial for multi-line fields.
    match = re.search(rule.rule, text, re.DOTALL)

    if match:
        try:
            # .group(1) extracts the text from the *first capture group*
            # This is the standard for extraction regex.
            return match.group(1).strip()
        except IndexError:
            # This happens if the regex matched but had NO capture group.
            # We can fall back to group(0), the full match.
            return match.group(0).strip()

    return None  # No match found


def execute_rule(rule: Rule, text: str) -> Optional[str]:
    """Executes a given extraction rule on the input text.

    This function acts as a dispatcher, calling the correct
    sub-function based on the rule's 'type'.
    """
    try:
        if rule.type == "regex":
            return _execute_regex_rule(rule, text)
        elif rule.type == "keyword":
            return _execute_keyword_rule(rule, text)
        elif rule.type == "position":
            return _execute_position_rule(rule, text)
    except Exception as e:
        # Catch any unexpected errors during rule execution
        print(f"Error executing rule (type: {rule.type}, rule: {rule.rule}): {e}")
        return None

    return None


def _validate_syntax(
    response: Dict[str, Any],
    field_name: str,
    attempt: int,
    logger: logging.Logger,
) -> Tuple[Optional[Rule], Optional[str]]:
    stage = "syntax_validation"
    try:
        # 4. Validate Syntax (Schema)
        rule = Rule.model_validate(response.get("structured_response", {}))
        extra = (
            {
                "field": field_name,
                "attempt": attempt,
                "stage": stage,
            },
        )
        logger.debug(
            f"Syntax validation successful: {extra}",
        )
        return rule, None
    except Exception as e:
        feedback = (
            f"- ATTEMPT {attempt} FAILED: The JSON was malformed or failed schema validation. "
            f"Error: {e}. Make sure to return ONLY valid JSON matching the schema."
        )
        extra = (
            {
                "field": field_name,
                "attempt": attempt,
                "stage": stage,
                "error": str(e),
                "raw_response": response,
            },
        )
        logger.warning(
            f"Syntax validation failed: {extra}",
        )
        return None, feedback


def _validate_extraction_rule(
    rule: Rule,
    text: str,
    field_value: str,
    field_name: str,
    attempt: int,
    logger: logging.Logger,
) -> Optional[str]:
    stage = "extraction_validation"
    extracted_val = None
    try:
        # 5. Validate Rule Execution (the 'rule')
        extracted_val = execute_rule(rule, text)  # Your re.search() function

        if extracted_val == field_value:
            extra = (
                {
                    "field": field_name,
                    "attempt": attempt,
                    "stage": stage,
                    "rule": rule.rule,
                    "extracted": extracted_val,
                },
            )
            logger.debug(
                f"Extraction rule validation successful: {extra}",
            )
            return None  # Success

        # Mismatch failure
        feedback = (
            f"- ATTEMPT {attempt} FAILED: The 'rule' was wrong. "
            f"Rule: `{rule.rule}`\n"
            f"  - Extracted: `{extracted_val}`\n"
            f"  - Expected: `{field_value}`\n"
            f"Please create a more precise regex."
        )
        extra = (
            {
                "field": field_name,
                "attempt": attempt,
                "stage": stage,
                "rule": rule.rule,
                "extracted": extracted_val,
                "expected": field_value,
            },
        )
        logger.warning(
            f"Extraction rule mismatch: {extra}",
        )
        return feedback

    except Exception as e:
        # Execution error
        feedback = (
            f"- ATTEMPT {attempt} FAILED: Error executing 'rule' regex. "
            f"Rule: `{rule.rule}`. Error: {e}"
        )
        extra = (
            {
                "field": field_name,
                "attempt": attempt,
                "stage": stage,
                "rule": rule.rule,
                "error": str(e),
            },
        )
        logger.warning(
            f"Extraction rule execution error: {extra}",
        )
        return feedback


def _validate_validation_regex(
    rule: Rule,
    field_value: str,
    field_name: str,
    attempt: int,
    logger: logging.Logger,
) -> Optional[str]:
    stage = "validation_regex_validation"
    try:
        # 6. Validate Validation Execution (the 'validation_regex')
        if re.match(rule.validation_regex, field_value):
            extra = (
                {
                    "field": field_name,
                    "attempt": attempt,
                    "stage": stage,
                    "validation_regex": rule.validation_regex,
                    "value_matched": field_value,
                },
            )
            logger.debug(
                f"Validation regex validation successful: {extra}",
            )
            return None  # Success

        # Mismatch failure
        feedback = (
            f"- ATTEMPT {attempt} FAILED: The 'validation_regex' was wrong.\n"
            f"  - Regex: `{rule.validation_regex}`\n"
            f"  - Did not match the expected value: `{field_value}`\n"
            f"  - Please create a 'validation_regex' that fully matches the expected value."
        )
        extra = (
            {
                "field": field_name,
                "attempt": attempt,
                "stage": stage,
                "validation_regex": rule.validation_regex,
                "expected_to_match": field_value,
            },
        )
        logger.warning(
            f"Validation regex mismatch: {extra}",
        )
        return feedback

    except Exception as e:
        # Execution error
        feedback = (
            f"- ATTEMPT {attempt} FAILED: Error in 'validation_regex'. "
            f"Regex: `{rule.validation_regex}`. Error: {e}"
        )
        extra = (
            {
                "field": field_name,
                "attempt": attempt,
                "stage": stage,
                "validation_regex": rule.validation_regex,
                "error": str(e),
            },
        )
        logger.warning(
            f"Validation regex execution error: {extra}",
        )
        return feedback


def generate_robust_rule(
    agent_rule,
    text: str,
    field_name: str,
    field_value: str,
    field_description: str,
    all_fields: List[str],
    max_attempts: int = 3,
) -> tuple[Optional[Rule], int, int]:
    """Generate a robust extraction rule with validation.

    Returns:
        tuple: (rule, total_prompt_tokens, total_completion_tokens)
    """
    # TODO Clean everything here
    total_prompt_tokens = 0
    total_completion_tokens = 0

    extra = (
        {
            "field": field_name,
            "field_value": field_value,
        },
    )
    logger.info(
        f"Starting robust rule generation for field '{field_name}' with value '{field_value}': {extra}"
    )

    # 1. Prepare the base prompt
    base_prompt = create_rule_generation_prompt(
        text, field_name, field_value, field_description, all_fields
    )
    feedback_history: List[str] = []  # Stores feedback from failures

    for attempt in range(max_attempts):
        current_attempt = attempt + 1
        extra = (
            {
                "field": field_name,
                "current_attempt": current_attempt,
                "max_attempts": max_attempts,
            },
        )
        logger.info(
            f"Starting attempt {current_attempt}/{max_attempts} for field '{field_name}': {extra}"
        )

        # 2. Build the prompt with feedback (if any)
        current_prompt = base_prompt
        if feedback_history:
            feedback_str = "\n".join(feedback_history)
            current_prompt += f"""
            ---
            You have tried before. Analyze the feedback and generate a new rule.

            FEEDBACK FROM PREVIOUS ATTEMPTS:
            {feedback_str}

            Generate a new and CORRECTED rule JSON:
            """
            extra = (
                {
                    "current_attempt": current_attempt,
                    "feedback_count": len(feedback_history),
                },
            )
            logger.debug(
                f"Feedback added to prompt for attempt {current_attempt}: {extra}"
            )

        # 3. Invoke Agent (LLM)
        extra = (
            {
                "current_attempt": current_attempt,
            },
        )
        logger.info(f"Invoking agent for attempt {current_attempt}: {extra}")
        response = agent_rule.invoke(
            {"messages": [{"role": "user", "content": current_prompt}]}
        )

        # Track token usage from this attempt
        ai_message = response["messages"][-1]
        if hasattr(ai_message, "response_metadata") and ai_message.response_metadata:
            if (
                "token_usage" in ai_message.response_metadata
                and ai_message.response_metadata["token_usage"]
            ):
                total_prompt_tokens += ai_message.response_metadata["token_usage"].get(
                    "prompt_tokens", 0
                )
                total_completion_tokens += ai_message.response_metadata[
                    "token_usage"
                ].get("completion_tokens", 0)

        # 4. Validate Syntax
        rule, feedback = _validate_syntax(response, field_name, current_attempt, logger)
        if feedback:
            feedback_history.append(feedback)
            continue  # Try again

        # 5. Validate Rule Execution
        feedback = _validate_extraction_rule(
            rule, text, field_value, field_name, current_attempt, logger
        )
        if feedback:
            feedback_history.append(feedback)
            continue  # Try again

        # 6. Validate Validation Regex
        feedback = _validate_validation_regex(
            rule, field_value, field_name, current_attempt, logger
        )
        if feedback:
            feedback_history.append(feedback)
            continue  # Try again

        # 7. Success!
        # All three validations (Syntax, Rule, Validation) passed.
        extra = (
            {
                "field": field_name,
                "final_attempt": current_attempt,
                "final_feedback_history": "\n".join(feedback_history),
            },
        )
        logger.info(
            f"Rule generation successful for field '{field_name}' after {current_attempt} attempts: {extra}",
        )
        return rule, total_prompt_tokens, total_completion_tokens

    # 8. Failure (after max_attempts)
    extra = (
        {
            "field": field_name,
            "attempts": max_attempts,
            "final_feedback_history": "\n".join(feedback_history),
        },
    )
    logger.error(
        f"Failed to generate a valid rule for field '{field_name}' after {max_attempts} attempts: {extra}",
    )
    print(f"ALERT: Failed to generate a valid rule for field '{field_name}'.")
    return None, total_prompt_tokens, total_completion_tokens
